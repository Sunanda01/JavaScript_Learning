<!-- //EVENT PROPAGATION
    //It determines in which order the elements receive the event.
    //Two ways of event propagation in the HTML DOM API, which an event occurs in an element inside another element, and both elements have registered a handle for that event. 
    //CAPTURE PHASE
        //Top to Bottom
        //Going from the window to the event target phase
    //BUBBLE PHASE
        //Bottom to Top
        //From the event target parent back to the window
      //Target Phase
        //It is the target phase
//EVENT BUBBLING
    //With event bubbling, the event is first captured and handled by the innermost element and then propagated to outer element
//EVENT CAPTURING
    //With event capturing, the event is first captured by the outermost element and propagated to the inner elements.
    //Capturing also known as "trickling", helps in remembering the propagation order.
//HIGHER ORDER FUNCTION
    //function which takes another function as an argument
//CALLBACK FUNCTION
    //function which get passed as an argument to an another function to be called back -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>abc</title>
    <style>
        .parentdiv{
            height: 25em;
            width: 25em;
            background-color: aqua;
            position: absolute;
        }
        .childiv{
            position: relative;
            background-color: yellow;
            height: 12.5em;
            width: 12.5em;
            margin: 6.25em;
        }
    </style>
</head>
<body>
    <div class="parentdiv" id="parentid">
        <div class="childiv" id="childid"></div>
    </div>
    <script>
        const parentid=document.getElementById('parentid');
        const childid=document.getElementById('childid');
        const parentcall=()=>{
            alert(`parent div call`);
        }
        const childcall=()=>{
            alert(`child div call`);
            // event.stopPropagation();        //only for single alert
        }
        //by default event bubbling
        parentid.addEventListener('click',parentcall,true);  //by default 3rd parameter is false for bubbling
        childid.addEventListener('click',childcall,true);       //true for capture phase

        // <!-- CALCULATOR -->
            const add=(a,b)=>{
                return a+b;
            }
            const mul=(a,b)=>{
                return a*b;
            }
            const sub=(a,b)=>{
                return a-b;
            }
            const divide=(a,b)=>{
                return a/b;
            }
            const calculator=(num1,num2,operator)=>{
                return operator(num1,num2);
            }
            console.log(calculator(10,20,mul));
            //calculator() is high order and operator() is call back
// CURRYING
    //It is a technique of evaluating function with multiple arguments into sequence of function with single argument.
        sum(5)(3)(8)
        function sum(num1){
            // console.log(num1);
            return function(num2){
                // console.log(num2);
                return function(num3){
                    console.log(num1+num2+num3);            //16
                }
            }
        }
        //Single Line
        const sum=(num1)=>(num2)=>(num3)=>console.log(num1+num2+num3);  
        sum1 (10) (10) (10)         //30
//CALLBACK HELL
        setTimeout(()=>{
            console.log(`WORK IS DONE`);
            setTimeout(()=>{
                console.log(`WORK IS DONE`);
                setTimeout(()=>{
                    console.log(`WORK IS DONE`);
                    setTimeout(()=>{
                        console.log(`WORK IS DONE`);
                        setTimeout(()=>{
                            console.log(`WORK IS DONE`);
                            setTimeout(()=>{
                                console.log(`WORK IS DONE`);
                            },1000)
                        },1000)
                    },1000)
                },1000)
            },1000)
        },1000)          
//AJAX: CALL API USING HTTP REQUEST ie GET AND POST
//PROMISE: FETCH API    


//MEMOIZATION
    //It is an optimization technique that can be used to reduce  time consuming calculations by saving previous input to something called cache and returning the 
    //result from it.
        //Example
        let sum=0;
        const cal=(n)=>{
            for(let i=0;i<n;i++){
                sum+=i;
            }
            return sum;
        }       
        const memo=(fun)=>{
            let cache={};
            return function(...args){
                let n=args[0];
                if(n in cache){
                    console.log("Cache");
                    return cache[n];
                }
                else{
                    console.log("1st time calculation");
                    let result=fun(n);
                    cache[n]=result;
                    return result;
                }
            }
        }
        console.time();
        const eff=memo(cal);
        console.log(eff(5));
        console.timeEnd();

        console.time();
        console.log(eff(5));
        console.timeEnd();

        //Output
        // 1st time calculation
        // 10
        // 8.048ms
        // Cache
        // 10
        // 0.568ms
    </script>
</body>
</html>


